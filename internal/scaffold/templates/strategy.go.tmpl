package {{.StrategyPackage}}

import (
    "time"

    "github.com/backtesting-org/kronos-sdk/pkg/types/connector"
    "github.com/backtesting-org/kronos-sdk/pkg/types/logging"
    "github.com/backtesting-org/kronos-sdk/pkg/types/portfolio"
    "github.com/backtesting-org/kronos-sdk/pkg/types/portfolio/store"
    "github.com/backtesting-org/kronos-sdk/pkg/types/strategy"
    "github.com/google/uuid"
    "github.com/shopspring/decimal"
)

type MovingAverageStrategy struct {
    *strategy.BaseStrategy
    assetStore store.Store
    logger     logging.TradingLogger

    // Strategy parameters
    shortPeriod int
    longPeriod  int
    exchange    connector.ExchangeName

    // Internal state for tracking MAs
    priceHistory map[string][]decimal.Decimal
}

func NewMovingAverageStrategy(
    assetStore store.Store,
    logger logging.TradingLogger,
) *MovingAverageStrategy {
    return &MovingAverageStrategy{
        assetStore:   assetStore,
        logger:       logger,
        shortPeriod:  10,
        longPeriod:   30,
        exchange:     connector.Binance,
        priceHistory: make(map[string][]decimal.Decimal),
    }
}

func (mas *MovingAverageStrategy) GetSignals() ([]*strategy.Signal, error) {
    // Get all assets with price data
    assets := mas.assetStore.GetAllAssetsWithOrderBooks()
    if len(assets) == 0 {
        return nil, nil
    }

    var signals []*strategy.Signal

    for _, asset := range assets {
        // Get current price from the store
        priceData := mas.assetStore.GetAssetPrice(asset, mas.exchange)
        if priceData == nil || priceData.Price.IsZero() {
            continue
        }

        currentPrice := priceData.Price
        assetKey := asset.Symbol()

        // Update price history
        mas.updatePriceHistory(assetKey, currentPrice)

        // Need enough data for long MA
        if len(mas.priceHistory[assetKey]) < mas.longPeriod {
            mas.logger.Debug(
                "moving-average",
                asset.Symbol(),
                "Not enough data: %d/%d periods",
                len(mas.priceHistory[assetKey]),
                mas.longPeriod,
            )
            continue
        }

        // Calculate moving averages
        shortMA := mas.calculateMA(assetKey, mas.shortPeriod)
        longMA := mas.calculateMA(assetKey, mas.longPeriod)

        // Generate signal based on crossover
        signal := mas.checkCrossover(asset, shortMA, longMA, currentPrice)
        if signal != nil {
            signals = append(signals, signal)
        }
    }

    return signals, nil
}

func (mas *MovingAverageStrategy) updatePriceHistory(assetKey string, price decimal.Decimal) {
    mas.priceHistory[assetKey] = append(mas.priceHistory[assetKey], price)

    // Keep only what we need (long period + buffer)
    maxLength := mas.longPeriod + 10
    if len(mas.priceHistory[assetKey]) > maxLength {
        mas.priceHistory[assetKey] = mas.priceHistory[assetKey][1:]
    }
}

func (mas *MovingAverageStrategy) calculateMA(assetKey string, period int) decimal.Decimal {
    prices := mas.priceHistory[assetKey]
    if len(prices) < period {
        return decimal.Zero
    }

    // Get last N prices
    startIdx := len(prices) - period
    sum := decimal.Zero

    for i := startIdx; i < len(prices); i++ {
        sum = sum.Add(prices[i])
    }

    return sum.Div(decimal.NewFromInt(int64(period)))
}

func (mas *MovingAverageStrategy) checkCrossover(
    asset portfolio.Asset,
    shortMA decimal.Decimal,
    longMA decimal.Decimal,
    currentPrice decimal.Decimal,
) *strategy.Signal {
    assetSymbol := asset.Symbol()

    // Bullish crossover: short MA crosses above long MA
    if shortMA.GreaterThan(longMA) {
        mas.logger.Opportunity(
            "moving-average",
            assetSymbol,
            "Bullish crossover - Short MA: %s > Long MA: %s, Current Price: %s",
            shortMA.String(),
            longMA.String(),
            currentPrice.String(),
        )
        return mas.createBuySignal(asset, currentPrice)
    }

    // Bearish crossover: short MA crosses below long MA
    if shortMA.LessThan(longMA) {
        mas.logger.Opportunity(
            "moving-average",
            assetSymbol,
            "Bearish crossover - Short MA: %s < Long MA: %s, Current Price: %s",
            shortMA.String(),
            longMA.String(),
            currentPrice.String(),
        )
        return mas.createSellSignal(asset, currentPrice)
    }

    return nil
}

func (mas *MovingAverageStrategy) createBuySignal(
    asset portfolio.Asset,
    price decimal.Decimal,
) *strategy.Signal {
    mas.logger.OrderLifecycle(
        "Creating BUY signal at price %s",
        asset.Symbol(),
        price.String(),
    )

    return &strategy.Signal{
        ID:       uuid.New(),
        Strategy: "MovingAverage",
        Actions: []strategy.TradeAction{
            {
                Action:   strategy.ActionBuy,
                Asset:    asset,
                Exchange: mas.exchange,
                Quantity: decimal.NewFromInt(100),
                Price:    price,
            },
        },
        Timestamp: time.Now(),
    }
}

func (mas *MovingAverageStrategy) createSellSignal(
    asset portfolio.Asset,
    price decimal.Decimal,
) *strategy.Signal {
    mas.logger.OrderLifecycle(
        "Creating SELL signal at price %s",
        asset.Symbol(),
        price.String(),
    )

    return &strategy.Signal{
        ID:       uuid.New(),
        Strategy: "MovingAverage",
        Actions: []strategy.TradeAction{
            {
                Action:   strategy.ActionSell,
                Asset:    asset,
                Exchange: mas.exchange,
                Quantity: decimal.NewFromInt(100),
                Price:    price,
            },
        },
        Timestamp: time.Now(),
    }
}

// Interface compliance methods
func (mas *MovingAverageStrategy) GetName() strategy.StrategyName {
    return "MovingAverage"
}

func (mas *MovingAverageStrategy) GetDescription() string {
    return "Moving average crossover strategy for {{.ProjectName}}"
}

func (mas *MovingAverageStrategy) GetRiskLevel() strategy.RiskLevel {
    return strategy.RiskLevelMedium
}

func (mas *MovingAverageStrategy) GetStrategyType() strategy.StrategyType {
    return "StrategyTypeMovingAverage"
}

// Ensure interface compliance
var _ strategy.Strategy = (*MovingAverageStrategy)(nil)
